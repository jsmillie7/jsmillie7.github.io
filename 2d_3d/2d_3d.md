<a href="/index">
<img src="/images/back.png" alt="Back" height="35" width="35">
</a>

## 3D to 2D G-code Optimizing Tool

##### Jupyter Notebook
---
### Background:

Since 2015, I have been working on a homemade CNC Laser Cutter. The 2 Watt laser is capable of cutting though thick paper, 3/16" foamcore, and balsa wood with enough passes. This is great for making 2 dimensional art or cutting things down to exact sizes, but not great for 3 dimensional structures. In order to solve this problem, I turned to inspiration from 3D printing, which is nothing more than a series of (roughly) 2-dimensional layers stacked on top of each other. Cutting out these layers and stacking them together was a viable option. Using thicker materials would reduce the number of layers needed, but also reduce the Z-axis resolution of the 3D object.

### Process:

#### Fusion 360 CAD Model

The first step in the process involved using Autodesk Fusion 360 to draw a CAD model of the desired shape. I chose to start with a simple design: a cardstock sphere with a hole running through it to put on an alignment bolt. An .STL file was created from the model below.

<p align="center">
  <img src="fusion360.png" width="100%">
</p>

#### Cura Slicing

Next, the STL needed to be sliced. While I could have just created a python file to slice and optimize, it was much simpler to use tools that were open source and already available. I created a custom printer and updated settings until I got the results I desired: no infill needed, just an outline of all of the surfaces. The resulting slicing is shown below.

<p align="center">
  <img src="cura.png" width="100%">
</p>

#### Python G-Code Parsing

Now, I had the files that I needed to create my 3D layered sphere. Ignoring the Z-Axis, since my laser cutter is only 2-axis, the resulting [g-code file](sphere.gcode) is a series of concentric circles around the middle of the cutting plate.

<p align="center">
  <img src="unmodified.png">
</p>

In order to parse the g-code file, I create a class called unSlicer2D which opens the recently sliced Cura g-code file. It immediately performs a few string operations to remove unneeded data from the original file.

```python
class unSlicer2D:
    def __init__(self, file):
        '''
        the x and y argument are the size of the laser bed in mm
        the buffer is the relative distance between each layer, treated as a rectange of size (x max - min) by (y max - min)
        this will not optimize the size needed to cut all layers, but will lay them all out into a cuttable configuration. 
        '''
        
        with open(file) as c:
            self.code = c.readlines()
        self.file = file
        self.code = [i.split(' E0')[0].split(' Z')[0] for i in self.code] # remove unneeded info
        self.num = [int(i.split(':')[-1].strip('\n')) for i in self.code if ";LAYER_COUNT:" in i][0]
        self.ranges = [self.code.index(';LAYER:{}\n'.format(i)) for i in range(self.num)]
        self.ranges.append(-1)
        self.layers = {i:Layer(self.code[self.ranges[i]:self.ranges[i+1]]) for i in range(self.num)} # Split the layers into separate instances
        self.pages = 1
```
During the initial parsing of the g-code file, each layer is separated into a new class object called Layer. This allows the program to make sure that each physical shape from the sliced object is kept together, and moved all together. maX and miX are max and min X values within the layer, respectively. Same for maY and miY in the Y direction.
```python
class Layer:
    def __init__(self, gcode):
        self.gcode = gcode
        self.lines = {num : Code(line) for num,line in enumerate(self.gcode)}
        self.page = 0
        self()
        
    def __call__(self):
        self.maX = max([x.X for x in self.lines.values() if x.X is not None])
        self.miX = min([x.X for x in self.lines.values() if x.X is not None])
        self.maY = max([y.Y for y in self.lines.values() if y.Y is not None])
        self.miY = min([y.Y for y in self.lines.values() if y.Y is not None])
```
Within the Layer setup, another class object called Code is created for each individual g-code line within each layer in order to keep the code processing as organized and clean as possible. Each line of code in the original g-code file is added as a Code object to the Layer object that it is assigned to. It saves the key values of a g-code line: the G, F, X and Y values. 
```python
class Code:
    def __init__(self, gcode):
        self.gcode = gcode
        self.G = None
        self.F = None
        self.X = None
        self.Y = None
        self.splitter()
        
    def splitter(self):
        if ';' in self.gcode: # this is a comment line and can be ignored
            return
        c1 = self.gcode.split(' ')
        g = [i for i in c1 if 'G' in i]
        f = [float(i.strip('F')) for i in c1 if 'F' in i]
        x = [float(i.strip('X')) for i in c1 if 'X' in i]
        y = [float(i.strip('Y')) for i in c1 if 'Y' in i]
        
        if len(g) > 0:
            self.G = g[0]
        if len(f) > 0:
            self.F = f[0]
        if len(x) > 0:
            self.X = x[0]
        if len(y) > 0:
            self.Y = y[0]
```

---
### Implementation
